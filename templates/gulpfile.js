/*
 * Gulpfile generated by slush-slush-atom-shell-dev
 */

var path = require('path'),
    fs = require('fs');

var gulp = require('gulp'),
    gutil =require('gulp-util'),
    _ = require('lodash'),
    bluebird = require('bluebird'),
    es = require('event-stream'),
    progress = require('progress'),
    request = require('request'),
    prompt = require('inquirer'),
    lowdb = require('lowdb'),
    mkdirp = require('mkdirp');

var supportPlatforms = {
    'linux-x64': ['atom-shell','atom'], 
    'linux-ia32': ['atom-shell','atom'],
    'darwin-x64': ['Atom.app','Contents','MacOS','Atom'],
    'win32-ia32': ['atom-shell','atom.exe']
};


gulp.task('configure', function(){
    var config = lowdb('configure.json'),
        current = _.has(config.object, 'values') ? config.object.values : [{}];

    return gulp.src('')
        .pipe(es.map(function(data, cb){
            prompt.prompt([
                {
                    type: 'input',
                    name: 'appname',
                    message: 'your application name',
                    default: (_.isUndefined(current[0].appname) ||  current[0].appname === '') ? 'testApp' : current[0].appname
                },
                {
                    type: 'checkbox',
                    name: 'platform',
                    choices: _.keys(supportPlatforms),
                    message: 'support platform(s)',
                    default: (_.isUndefined(current[0].platform) ||  current[0].platform === []) ? [_.keys(supportPlatforms)[0]] : current[0].platform
                },
                {
                    type: 'input',
                    name: 'version',
                    message: 'which version of atom-shell use',
                    default: (_.isUndefined(current[0].version) ||  current[0].version === '') ? 'latest' : current[0].version
                },
                {
                    type: 'input',
                    name: 'cachedir',
                    message: 'atom-shell binary download path',
                    default: (_.isUndefined(current[0].cachedir) ||  current[0].cachedir === '') ? path.join(__dirname, 'cache') : current[0].cachedir
                },
                {
                    type: 'input',
                    name: 'appdir',
                    message: 'application path (which include entry-point javascript file)',
                    default: (_.isUndefined(current[0].appdir) ||  current[0].appdir === '') ? path.join(__dirname, 'app') : current[0].appdir
                }
            ], function(answers){
                if(_.has(config.object, 'values')){
                    config('values').first().assign(answers);
                }else{
                    config('values').push(answers).value();
                }

                gutil.log('Configuration done. You just type <gulp run>.');
                cb();
            });
        }));
});


gulp.task('download', function(){
    var config = lowdb('configure.json'),
        current = !_.isUndefined(config.object.values) ? config.object.values[0] : null;

    return gulp.src('')
        .pipe(es.map(function(data, cb){
            request({
				        url: 'https://api.github.com/repos/atom/atom-shell/releases',
				        json: true,
				        headers: {
						        'User-Agent': "gulp-atom-shell-dev"
				        }
            }, function(error, response, body){
                cb(null, body);
            })
                .on('error', function(err){
                    cb(err);
                })
                .on('response',function(response){
                    if(response.statusCode !== 200){
                        cb({error:response.statusCode});
                    }
                });
        }))
        .pipe(es.map(function(data, cb){
            if(_.isNull(current)){
                gutil.log('Invalid OR Not found configure.json. Run <gulp configure> command first');
                return;
            }

            bluebird.all(current.platform).each(function(el){
                var done = bluebird.defer(),
                    releaseInfo = _.find(data, current.version === 'latest' ? {prerelease: false} : {'tag_name': current.version}),
                    pkgInfo = !_.isUndefined(releaseInfo) ? _.merge({platform:el, cachedir:current.cachedir}, releaseInfo) : null,
                    assetName = !_.isNull(pkgInfo) ? _.template('atom-shell-<%= tag_name %>-<%= platform %>.zip', pkgInfo) : null,
                    dirName = !_.isNull(pkgInfo) ? _.template('<%= cachedir %>,<%= tag_name %>,<%= platform %>', pkgInfo) : null,
                    foundAssets = !_.isNull(assetName) ? _.find(releaseInfo.assets, {name:assetName}) : null,
                    fullName, appPath, foundCache, bar;

                if(foundAssets){
                    dirName = dirName.split(',').join(path.sep);
                    fullName = path.join(dirName, assetName);

                    if(fs.existsSync(fullName)){
                        foundCache = fs.statSync(fullName);
                        if(foundCache.isFile() && (foundCache.size === foundAssets.size)){
                            gutil.log(_.template('found cache: <%= name %>', foundAssets));
                            appPath = {};
                            appPath[el] = path.join(fullName.replace(/\.zip$/, ''), (supportPlatforms[el]).join(path.sep));
                            config('values').first().merge({'activepkg':appPath});
                            return done.resolve('found cache');
                        }
                    }

                    mkdirp.sync(dirName);

                    request({
				                url: foundAssets.url,
				                headers: {
					                  'User-Agent': "gulp-atom-shell-dev",
					                  "Accept" : "application/octet-stream"
				                }
			              }, function(error, response, body){
                        appPath = {};
                        appPath[el] = path.join(fullName.replace(/\.zip$/, ''), (supportPlatforms[el]).join(path.sep));
                        config('values').first().merge({'activepkg':appPath});
                        
                        done.resolve(response);
                    }).on('response', function(response) {
                        gutil.log(_.template('download: <%= name %>', foundAssets));
				                bar = new progress('  [:bar] :percent :etas', {
                            complete: '=',
                            incomplete: ' ',
                            width: 20,
                            total: parseInt(response.headers['content-length'])
				                });
 			              }).on('data', function(chunk) {
				                if(bar){bar.tick(chunk.length);}
			              }).pipe(fs.createWriteStream(fullName));
                }else{
                    return done.reject('asset not found');
                }

                return done.promise;
            }).then(function(el){
                cb();
            });
        }));
});


gulp.task('extract', ['download'], function(){
    var config = !_.isUndefined(lowdb('configure.json').object.values) ? lowdb('configure.json').object.values[0] : null;

    return gulp.src(_.template('<%= cachedir %>/**/*.zip', config))
        .pipe(es.map(function(data, cb){
            var spawn = require('child_process').spawn,
                dest = data.history[0].replace(new RegExp('\\' + path.extname(data.history[0]) + '$'), path.sep),
                unzip = spawn('unzip', ['-qq', '-o', data.history[0], '-d', dest]);

		        if(process.platform === 'win32'){
                var decompressZip = require('decompress-zip');
		            unzip = new decompressZip(data.history[0]);
				        unzip
                    .on('error', function(err) {
						            cb(err);
				            })
                    .on('extract', function(log){
						            cb();
				            });
                unzip.extract({path: dest});
		        }else{
                unzip
                    .on('exit', function(code){
                        cb();
                    })
                    .on('error', function(error){
                        cb(error);
                    });
            }
        }));
});


gulp.task('run', ['extract'], function(){
    var config = !_.isUndefined(lowdb('configure.json').object.values) ? lowdb('configure.json').object.values[0] : null,
        executable = !_.isNull(config) ? config.activepkg[_.template('<%= platform %>-<%= arch %>', process)] : null;

    return gulp.src(executable)
        .pipe(es.map(function(data, cb){
            gutil.log('run application');
            require('child_process')
                .spawn(executable, [config.appdir])
                .on('close', function(code){
                    gutil.log('close application');
                    cb();
                });
        }));
});


// gulp.task('build', function(){
//     return;
// });


gulp.task('default', ['configure']);
